

//title: Number of Letters

//tags: arrays,sorting,strings

//url: https://edabit.com/challenge/xZapQmtZz4Eu5Zjqs

//Description:
//Create a function that takes a sentence and returns the number of letters in this sentence sorted alphabetically.
//Output format:
//letter:count space letter:count (see examples).
//Special cases:
//space is NOT a letter!
//special symbols like ($ & * @ ! ' @') is NOT a letter!
//lower and upper letters IS EQUAL (A == a, B == b ... Z == z)!
//Examples
//charCount("Hello world!") ➞ "d:1 e:1 h:1 l:3 o:2 r:1 w:1"
//
//charCount("Cheers, love! Hahaha.") ➞ "a:3 c:1 e:3 h:4 l:1 o:1 r:1 s:1 v:1"
//
//charCount("Now, I learn JavaScript") ➞ "a:3 c:1 e:1 i:2 j:1 l:1 n:2 o:1 p:1 r:2 s:1 t:1 v:1 w:1"
//Notes
//Output should be in lowercase.

//code area
///////////////////////////////////////////////////////////////////////////
const charCount = str => {
    let split = str.toLowerCase().match(/[a-z]+/g).join('').split('')
    let sorted = split.sort()
    let counted = Object.create(null)

    for (let letter of sorted) {
        let count =  counted[letter] ?? 0
        counted[letter] = count + 1
    }
    return Object.entries(counted).join(' ').replaceAll(',', ':')
}
//////////////////////////////////////////////////////////////////////////

//tests:

// Test.assertEquals(charCount('Hello world!'), 'd:1 e:1 h:1 l:3 o:2 r:1 w:1', 'Wrong result!')
// Test.assertEquals(charCount('Now, I learn JavaScript'), 'a:3 c:1 e:1 i:2 j:1 l:1 n:2 o:1 p:1 r:2 s:1 t:1 v:1 w:1', 'Wrong result!')
// Test.assertEquals(charCount('Cheers, love! Hahaha.'), 'a:3 c:1 e:3 h:4 l:1 o:1 r:1 s:1 v:1', 'Wrong result!')
// Test.assertEquals(charCount('Guess I won’t be using that.'), 'a:1 b:1 e:2 g:2 h:1 i:2 n:2 o:1 s:3 t:3 u:2 w:1', 'Wrong result!')
// Test.assertEquals(charCount('Ando en buena racha. ¡Fuera de mi camino!'), 'a:6 b:1 c:2 d:2 e:4 f:1 h:1 i:2 m:2 n:4 o:2 r:2 u:2', 'Wrong result!')
// Test.assertEquals(charCount('I’m on fire! Touch me, and you’ll get burned.'), 'a:1 b:1 c:1 d:2 e:4 f:1 g:1 h:1 i:2 l:2 m:2 n:3 o:3 r:2 t:2 u:3 y:1', 'Wrong result!')

//////////////////////////////////////////////////
//////////////////////////////////////////////////
//////////////////////////////////////////////////
//////////////////////////////////////////////////
//////////////////////////////////////////////////
//////////////////////////////////////////////////


//title: iccanobiF Numbers

//tags: loops,math,numbers

//url: https://edabit.com/challenge/2hz5RgarNMRaCayjF

//Description:
//The Fibonacci sequence, as you know, is generated by iterative addition of the sum of the last two elements of the sequence to the end of the sequence, starting with [0, 1].
//Fibonacci = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, …]
//The iccanobiF sequence (see Resources tab for more info) is generated in a similar way — except that the digits of the last two elements should first be reversed, then added together, then added to the sequence. Single-digit numbers are unaffected, so the first 8 elements are identical to the Fibonacci sequence:
//iccanobiF = [0, 1, 1, 2, 3, 5, 8, 13]
//The next element is the sum of the reverse of 8 (still 8), and the reverse of 13 — 31 (8 + 31 = 39).
//iccanobiF = [0, 1, 1, 2, 3, 5, 8, 13, 39]
//The next element is 31 + 93 = 124
//iccanobiF = [0, 1, 1, 2, 3, 5, 8, 13, 39, 124]
//And so on.
//Create a function that takes a number n and returns the difference between the nth iccanobiF number and the nth Fibonacci number.
//Examples
//iccMinusFib(4) ➞ 0
//// For all n < 9, the difference is zero.
//
//iccMinusFib(9) ➞ 18
//
//iccMinusFib(18) ➞ 790920
//Notes
//N/A

//code area
///////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////

//tests:

//Test.assertEquals(iccMinusFib(4),0)
//Test.assertEquals(iccMinusFib(9),18)
//Test.assertEquals(iccMinusFib(11),459)
//Test.assertEquals(iccMinusFib(20),9675657)
//Test.assertEquals(iccMinusFib(33),171358911)
//Test.assertEquals(iccMinusFib(18),790920)
//Test.assertEquals(iccMinusFib(49),996434352243)
//Test.assertEquals(iccMinusFib(31),93535758)

//////////////////////////////////////////////////
//////////////////////////////////////////////////
//////////////////////////////////////////////////
//////////////////////////////////////////////////
//////////////////////////////////////////////////
//////////////////////////////////////////////////


//title: Decompose Address

//tags: regex,strings

//url: https://edabit.com/challenge/xAc7G3AzGgQzLabTe

//Description:
//Create a function that decomposes an address string into an array of five substrings:
//Street Number
//Street Name
//City Name
//State
//Zip Code
//Examples
//decomposeAddress("557 Farmer Rd Corner, MT 59105")
//➞ ["557", "Farmer Rd", "Corner", "MT", "59105"]
//
//decomposeAddress("3315 Vanity St Beverly Hills, CA 90210")
//➞ ["3315", "Vanity St", "Beverly Hills", "CA", "90210"]
//
//decomposeAddress("8919 Scarecrow Ct Idaho Falls, ID 80193")
//➞ ["8919", "Scarecrow Ct", "Idaho Falls", "ID", "80193"]
//Notes
//All street extensions will be shortened to two-letter formats.

//code area
///////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////

//tests:

//Test.assertSimilar(decomposeAddress("3315 Vanity St Beverly Hills, CA 90210"), ["3315", "Vanity St", "Beverly Hills", "CA", "90210"])
//Test.assertSimilar(decomposeAddress("557 Farmer Rd Corner, MT 59105"), ["557", "Farmer Rd", "Corner", "MT", "59105"])
//Test.assertSimilar(decomposeAddress("8919 Scarecrow Ct Idaho Falls, ID 80193"), ["8919", "Scarecrow Ct", "Idaho Falls", "ID", "80193"])
//Test.assertSimilar(decomposeAddress("91 Ronald Dr Stenton, MS 39073"), ["91", "Ronald Dr", "Stenton", "MS", "39073"])
//Test.assertSimilar(decomposeAddress("25000 Meek Pl Bozerman, MT 59104"), ["25000", "Meek Pl", "Bozerman", "MT", "59104"])

